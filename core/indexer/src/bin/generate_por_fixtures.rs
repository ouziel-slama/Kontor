use std::fs;
use std::path::PathBuf;

use anyhow::{Result, anyhow};
use kontor_crypto::{
    FileLedger, PorSystem,
    api::{self, Challenge, FieldElement},
};
use serde::Serialize;

#[derive(Debug, Serialize)]
struct PorProofFixtures {
    invalid_proof_hex: String,
    cross_block_agg_hex: String,
    note: String,
}

fn prepare_test_file(content: &[u8], filename: &str) -> (api::PreparedFile, api::FileMetadata) {
    let mut nonce = [0u8; 32];
    for (i, b) in filename.bytes().enumerate().take(32) {
        nonce[i] = b;
    }
    api::prepare_file(content, filename, &nonce).expect("Failed to prepare file")
}

fn write_fixtures(fixtures: &PorProofFixtures) -> Result<()> {
    let output_path = PathBuf::from(env!("CARGO_MANIFEST_DIR"))
        .join("tests")
        .join("fixtures")
        .join("por_proof_fixtures.json");
    if let Some(parent) = output_path.parent() {
        fs::create_dir_all(parent)?;
    }
    let json = serde_json::to_string_pretty(fixtures)?;
    fs::write(&output_path, json)?;
    println!("Wrote fixtures to {}", output_path.display());
    Ok(())
}

fn main() -> Result<()> {
    let invalid_proof_hex = generate_invalid_proof_hex()?;
    let cross_block_agg_hex = generate_cross_block_agg_hex()?;

    let fixtures = PorProofFixtures {
        invalid_proof_hex,
        cross_block_agg_hex,
        note: "Generated by generate_por_fixtures".to_string(),
    };

    write_fixtures(&fixtures)
}

fn generate_invalid_proof_hex() -> Result<String> {
    let file1_content = b"First file content for testing";
    let (_prepared_file1, _metadata1) = prepare_test_file(file1_content, "file1.txt");

    let file2_content = b"Second file with different content";
    let (prepared_file2, metadata2) = prepare_test_file(file2_content, "file2.txt");

    let mut ledger = FileLedger::new();
    ledger.add_file(&metadata2)?;

    let block_height = 20000u64;
    let seed = FieldElement::from(99u64);
    let challenge = Challenge::new(
        metadata2.clone(),
        block_height,
        100,
        seed,
        "node_1".to_string(),
    );

    let system = PorSystem::new(&ledger);
    let proof = system
        .prove(vec![&prepared_file2], std::slice::from_ref(&challenge))
        .map_err(|e| anyhow!("Failed to generate proof: {e}"))?;
    let mut bytes = proof
        .to_bytes()
        .map_err(|e| anyhow!("Failed to serialize proof: {e}"))?;

    if let Some(last) = bytes.last_mut() {
        *last ^= 0x01;
    }

    Ok(hex::encode(bytes))
}

fn generate_cross_block_agg_hex() -> Result<String> {
    let (prepared_a, metadata_a) =
        prepare_test_file(b"Content of file A for cross-block", "cross_a.txt");
    let (prepared_b, metadata_b) =
        prepare_test_file(b"Content of file B for cross-block", "cross_b.txt");
    let (_prepared_c, metadata_c) =
        prepare_test_file(b"Content of file C - new agreement", "cross_c.txt");

    let mut ledger = FileLedger::new();
    ledger.add_file(&metadata_a)?;
    ledger.add_file(&metadata_b)?;
    ledger.add_file(&metadata_c)?;

    let block_height = 40000u64;
    let challenge_a = Challenge::new(
        metadata_a.clone(),
        block_height,
        100,
        FieldElement::from(200u64),
        "node_1".to_string(),
    );
    let challenge_b = Challenge::new(
        metadata_b.clone(),
        block_height,
        100,
        FieldElement::from(201u64),
        "node_1".to_string(),
    );
    let challenges = vec![challenge_a, challenge_b];

    let system = PorSystem::new(&ledger);
    let proof = system
        .prove(vec![&prepared_a, &prepared_b], &challenges)
        .map_err(|e| anyhow!("Failed to generate aggregated proof: {e}"))?;
    let bytes = proof
        .to_bytes()
        .map_err(|e| anyhow!("Failed to serialize proof: {e}"))?;
    Ok(hex::encode(bytes))
}
