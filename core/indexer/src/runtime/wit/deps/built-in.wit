package kontor:built-in;

interface context {
    resource signer {
        to-string: func() -> string;
    }

    resource view-context {
        get-str: func(path: string) -> option<string>;
        get-u64: func(path: string) -> option<u64>;
        get-s64: func(path: string) -> option<s64>;
        is-void: func(path: string) -> bool;
        exists: func(path: string) -> bool;
        matching-path: func(regexp: string) -> option<string>;
    }

    resource proc-context {
        get-str: func(path: string) -> option<string>;
        get-u64: func(path: string) -> option<u64>;
        get-s64: func(path: string) -> option<s64>;
        is-void: func(path: string) -> bool;
        exists: func(path: string) -> bool;
        matching-path: func(regexp: string) -> option<string>;

        set-str: func(path: string, value: string);
        set-u64: func(path: string, value: u64);
        set-s64: func(path: string, value: s64);
        set-void: func(path: string);

        signer: func() -> signer;
        view-context: func() -> view-context;
    }

    resource fall-context {
        signer: func() -> option<signer>;
        proc-context: func() -> option<proc-context>;
        view-context: func() -> view-context;
    }
}

interface foreign {
    use context.{signer};

    record contract-address {
        name: string,
        height: s64,
        tx-index: s64,
    }

    call: func(contract-address: contract-address, signer: option<borrow<signer>>, expr: string) -> string;
}

interface crypto {
    hash: func(input: string) -> tuple<string, list<u8>>;
    hash-with-salt: func(input: string, salt: string) -> tuple<string, list<u8>>;
    generate-id: func() -> string;
}

interface error {
    variant error {
        message(string),
    }

    meta-force-generate-error: func(e: error);
}

world built-in {
    import context;
    import foreign;
    import crypto;
    import error;
}
